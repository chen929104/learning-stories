# js 中 Number 精度耗损 浮点数 IEEE754

js 中的 Number 类型的值是根据 IEEE754 中的双精度的格式来存储的。

## 浮点数

浮点型数据是用来表示有小数部分的实数。在浮点数中一个数值可以根据小数点和指数的不同有不同的形式。例如:3.1415926 可以表示成 0.31415926*10e1,3.1415926*10e0,31.415926*10e2,0.031415926*10e2 等等。他们是同一个值,由此可以看出小数点的位置可以改变,只要在改变小数点位置的时候同时改变指数的值,就可以表示同一个数值。由于小数点的位置可以进行改变,所以实数的指数形式成为浮点数。

## 浮点数单精度和双精度的存储方式

浮点数的存储结构分为单精度和双精度。单精度总共 4 字节 32 位，双精度总共 8 字节 64 位。 <br/> ![单精度浮点数](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/f5116db8db5340b4b343c4f11f7911cb~tplv-k3u1fbpfcp-zoom-1.image) <br/> ![双精度浮点数](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/f5116db8db5340b4b343c4f11f7911cb~tplv-k3u1fbpfcp-zoom-1.image)

首位表示整个数组的正负,

- float 阶码部分由八位组成代表着+2<sup>7</sup>~-2<sup>7</sup>位数部分 23 位
- double 阶码部分由 11 位组成代表着+2<sup>10</sup>~-2<sup>10</sup>位数部分 52 位

## 以单精度为例，探讨十进制小数转化二进制过程：

十进制小数需要先转化为二进制小数，再进行存储。

- 小数先转二进制数
- 格式化为"尾数+阶码"的形式，即 1.M \* 2E−127{2^{E-127}}2E−127（M 为二进制小数，E 为阶码，127 为偏移量，E - 偏移量 = 实际的二进制指数）
- 分别存储"符号"、"阶码"、"尾数" 3 个纬度的信息

以 123.456 为例子：

```
/**
 * 十进制转二进制
 * 整数部分：不断除2，取余数，直到商为0
 * 小数部分：不断乘2，取整数，直到积为0
 *
 * 计算过程
 * 整数
 *  123/2 = 61(1);
 *  61/2 = 30(1);
 *  30/2 = 15(0);
 *  15/2 = 7(1);
 *  7/2 = 3(1);
 *  3/2 = 1(1);
 *  1/2 = 0(1);
 * 逆向取值，所以整数转为二进制：1111011
 *
 * 小数
 *  0.456*2 = 0.912(0);
 *  0.912*2 = 1.824(1);
 *  0.824*2 = 1.648(1);
 *  0.648*2 = 1.296(1);
 *
 *  0.296*2 = 0.592(0);
 *  0.592*2 = 1.184(1);
 *  0.184*2 = 0.368(0);
 *  0.368*2 = 0.736(0);
 *  ... 无限不循环
 *
 * 正向取值，所以小数转化为二进制：0111 0100 1011 1100 0110 1010 0111 1110 1111 1001 1101 1011
 *
 * 故该十进制对应的二进制数为：1111011.011101001011110001101010011111101111100111011011
 * 转成"尾数+阶码"的格式为：1.111011011101001011110001101010011111101111100111011011 * 2^6，所以阶码E应该为 6 + 127 = 133
 * 精度损失之后保留23位：1.11101101110100101111000 * 2^6
 *
 * 符号为正，故是0
 * 阶码为6，而存储阶码时，32位偏移量为127（64位为1023），所以实际应该存 127+6 = 133，转成二进制为 1000 0101
 * 尾数直接取二进制小数 11101101110100101111000
 * 最后转成单精度的值为 0 10000101 11101101110100101111000
 */
```
